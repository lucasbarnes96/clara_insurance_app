# Clara Insurance: A Trusted Expert Advisor

This repository contains the source code for Clara, a sophisticated AI-powered insurance platform. Our mission is to combine the mathematical precision of deterministic actuarial science with the insightful, educational guidance of an expert insurance broker.

Our system is built on a counter-narrative to the prevailing industry mindset. We follow the **"Highway Strategy"**: by systematically focusing on the top 80% of responsible, low-risk insurance profiles, we can provide a superior, efficient, and profitable service that our competitors cannot match.

---

## Core Philosophy: The Hybrid Intelligence Model

Clara is not a monolithic AI. It is a hybrid system where different components have distinct, inviolable roles. This ensures reliability, accuracy, and trust.

1.  **The Deterministic Core:** The math is sacred. All risk and pricing calculations are handled by a 100% deterministic engine that uses data from our actuarial tables. It is predictable, auditable, and free from AI "hallucinations."
2.  **The AI Agent Layer:** The AI's role is to explain the math. Our agents (`CustomerAgent`, `OperationsAgent`) act as intelligent communicators, data gatherers, and analysts. They use the Gemini 2.5 Flash engine to provide insights and make the numbers understandable, but they **never** modify the calculations.
3.  **Human-in-the-Loop (HITL):** Every quote generated by the system is reviewed by a human expert via a live dashboard before it is presented to a customer. This ensures quality, accountability, and expert oversight.

---

## Technology Stack

-   **Backend:** Node.js, Express, TypeScript
-   **Real-time Communication:** Socket.IO for live dashboard and client updates
-   **AI Engine:** Google Gemini 2.5 Flash via `gemini.ts` service
-   **Data Store (Demo Mode):** A self-contained, in-memory data store (`memoryDataStore.ts`) for rapid, dependency-free local demonstrations. Data is ephemeral.
-   **Frontend:** Plain HTML, CSS, and JavaScript for the customer and dashboard interfaces.

---

## Project Structure

```
.
├── public/               # Static frontend assets (HTML, JS, CSS)
├── src/
│   ├── agents/           # Core AI agent logic
│   │   ├── CustomerAgent.ts
│   │   └── OperationsAgent.ts
│   ├── services/         # Core services (Gemini, Actuarial, Data)
│   │   ├── actuarialService.ts
│   │   ├── gemini.ts
│   │   └── memoryDataStore.ts
│   ├── tools/            # Deterministic business logic tools
│   │   ├── riskEngine.ts
│   │   └── quoteGenerator.ts
│   ├── types/            # TypeScript interfaces
│   │   └── index.ts
│   └── server.ts         # Express server, WebSocket handling, API endpoints
├── z_actuarial_data/     # The single source of truth for all calculations (JSON)
└── z_markdowns/          # Core strategic and design documents
```

---

## How It Works: The Workflow

The system follows a simple, linear, and predictable workflow:

1.  **Data Collection (`CustomerAgent`):** A user interacts with the `CustomerAgent` via a simple web interface. The agent intelligently gathers the essential data required for an insurance quote.
2.  **Risk Assessment (`OperationsAgent` & `RiskEngine`):** The data is passed to the `OperationsAgent`. It uses the deterministic `RiskEngine` to calculate a risk score based *only* on the rules in `z_actuarial_data/`.
3.  **The "Hard Fork":**
    *   **Low Risk:** If the profile passes our deterministic filters, the `QuoteGenerator` tool creates quotes from multiple carriers. The `OperationsAgent` then uses its AI brain to analyze the quotes and prepare a recommendation package.
    *   **High Risk:** If the profile fails a filter, the process **stops**. No quotes are generated. The agent creates an internal-facing summary explaining the reason for the rejection.
4.  **Human Review (HITL Dashboard):** The package (either for approval or rejection) is sent to the live dashboard for a human expert to review.
5.  **Quote Presentation (`CustomerAgent`):** Once the human expert makes a final decision, the `CustomerAgent` is re-engaged to present the outcome to the user, providing intelligent insights and explanations.

---

## Quick Start

### 1. Prerequisites
- Node.js (v18 or later)
- An API key for Google Gemini, stored in a `.env` file.

### 2. Installation
```bash
npm install
```

### 3. Environment Configuration
Create a `.env` file in the root of the project and add your Gemini API key:
```
GEMINI_API_KEY="YOUR_API_KEY_HERE"
```

### 4. Running the Application
This command will start the Express server and the WebSocket connections.
```bash
npm run dev
```
The server will be running at `http://localhost:3000`.

-   **Customer Interface:** Open `public/customer.html` in your browser.
-   **HITL Dashboard:** Open `public/dashboard.html` in your browser.
-   **Health Check:** `http://localhost:3000/health`

---

## Future Enhancements (Demo V2 & Beyond)

Our immediate roadmap is focused on enhancing the demo to prove our strategic viability.

-   **Implement Deterministic Risk Filter:** Build out the explicit, hard-coded filtering logic that defines our "80/20" risk appetite using mock external API services.
-   **Enhance HITL Dashboard:** Improve the dashboard to clearly visualize the output of the risk filter and provide a more robust review experience.
-   **Full Firestore Integration:** Migrate from the in-memory store to Google Firestore for a scalable, production-ready persistence layer.
-   **AI Claims Concierge:** Build out the post-purchase claims advisory workflow, a key long-term differentiator.

This project is licensed under the MIT License. 